**인접행렬**: 그래프의 모든 노드를 2차원 배열로 표현하며, 배열의 값은 각 노드간의 연결 여부를 나타냅니다.  
즉, (i, j) 요소가 1이면 노드 i와 j가 연결되어 있음을 의미하며, 0이면 연결되어 있지 않음을 의미합니다.

- 장점 : 연결 관계를 빠르게 확인 가능
- 단점 : 모든 연결 정보가 배열에 저장되기 때문에, 불필요한 공간 낭비

**인접리스트**: 각 노드의 인접한 노드들의 리스트를 저장합니다.  
즉, 노드 i와 인접한 노드들의 리스트를 i번째 인덱스에 저장합니다.

- 장점 : 연결 정보를 리스트로 표현하기 때문에, 추가 삭제가 쉽다.
- 단점 : 연결 정보를 확인하기 위해서는 리스트를 탐색해야 함. 탐색 부분에서 속도가 느리다.  

## 인접행렬 구현
``` python
n = 5  # 노드 개수
graph = [[0] * n for _ in range(n)]  # 모든 요소가 0인 n x n 배열 생성
graph[0][1] = 1  # 노드 0과 1 연결
graph[1][0] = 1  # 노드 1과 0 연결
graph[0][2] = 1  # 노드 0과 2 연결
graph[2][0] = 1  # 노드 2와 0 연결

# [[0, 1, 1, 0, 0], [1, 0, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
print(graph)
```

## 인접리스트 구현
``` python
graph = [[] for _ in range(n)]  # n개의 빈 리스트 생성
graph[0].append(1)  # 노드 0과 1 연결
graph[1].append(0)  # 노드 1과 0 연결
graph[0].append(2)  # 노드 0과 2 연결
graph[2].append(0)  # 노드
# [[1, 2], [0], [0], [], []]
print(graph)
```

# DFS
깊이 우선 탐색, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘
stack 
- 탐색 : O(n)
- push, pop : O(1)
``` python
def dfs(graph,v,visited):
    # 현재 노드를 방문 처리
    visited[v]=True
    print(v,end=' ')
    # 현재 노드와 연결된 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(graph,i,visited)

# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph=[
    [],
    [2,3,8],
    [1,7],
    [1,4,5],
    [3,5],
    [3,4],
    [7],
    [2,6,8],
    [1,7],
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현
visited=[False]*9

dfs(graph,1,visited)

# 출력 결과 : 1 2 7 6 8 3 4 5
```